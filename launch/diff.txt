1d0
< [0m[ INFO] [1511100480.835449661]: Starting node...[0m
6,13d4
< Param: Bayes/FullPredictionUpdate = "false"                [Regenerate all the prediction matrix on each iteration (otherwise only removed/added ids are updated).]
< Param: Bayes/PredictionLC = "0.1 0.36 0.30 0.16 0.062 0.0151 0.00255 0.000324 2.5e-05 1.3e-06 4.8e-08 1.2e-09 1.9e-11 2.2e-13 1.7e-15 8.5e-18 2.9e-20 6.9e-23" [Prediction of loop closures (Gaussian-like, here with sigma=1.6) - Format: {VirtualPlaceProb, LoopClosureProb, NeighborLvl1, NeighborLvl2, ...}.]
< Param: Bayes/VirtualPlacePriorThr = "0.9"                  [Virtual place prior]
< Param: DbSqlite3/CacheSize = "10000"                       [Sqlite cache size (default is 2000).]
< Param: DbSqlite3/InMemory = "false"                        [Using database in the memory instead of a file on the hard disk.]
< Param: DbSqlite3/JournalMode = "3"                         [0=DELETE, 1=TRUNCATE, 2=PERSIST, 3=MEMORY, 4=OFF (see sqlite3 doc : "PRAGMA journal_mode")]
< Param: DbSqlite3/Synchronous = "0"                         [0=OFF, 1=NORMAL, 2=FULL (see sqlite3 doc : "PRAGMA synchronous")]
< Param: DbSqlite3/TempStore = "2"                           [0=DEFAULT, 1=FILE, 2=MEMORY (see sqlite3 doc : "PRAGMA temp_store")]
31,105d21
< Param: Grid/3D = "true"                                    [A 3D occupancy grid is required if you want an Octomap. Set to false if you want only a 2D map, the cloud will be projected on xy plane. A 2D map can be still generated if checked, but it requires more memory and time to generate it. Ignored if laser scan is 2D and "Grid/FromDepth" is false.]
< Param: Grid/3DGroundIsObstacle = "false"                   [[Grid/3D=true] Ground is an obstacle. Use this only if you want an Octomap with ground identified as an obstacle (e.g., with an UAV).]
< Param: Grid/CellSize = "0.05"                              [Resolution of the occupancy grid.]
< Param: Grid/ClusterRadius = "0.1"                          [[Grid/NormalsSegmentation=true] Cluster maximum radius.]
< Param: Grid/DepthDecimation = "4"                          [[Grid/DepthDecimation=true] Decimation of the depth image before creating cloud. Negative decimation is done from RGB size instead of depth size (if depth is smaller than RGB, it may be interpolated depending of the decimation value).]
< Param: Grid/DepthMax = "4.0"                               [[Grid/FromDepth=true] Maximum cloud's depth from sensor. 0=inf.]
< Param: Grid/DepthMin = "0.0"                               [[Grid/FromDepth=true] Minimum cloud's depth from sensor.]
< Param: Grid/DepthRoiRatios = "0.0 0.0 0.0 0.0"             [[Grid/FromDepth=true] Region of interest ratios [left, right, top, bottom].]
< Param: Grid/FlatObstacleDetected = "true"                  [[Grid/NormalsSegmentation=true] Flat obstacles detected.]
< Param: Grid/FootprintHeight = "0.0"                        [Footprint height used to filter points over the footprint of the robot. Footprint length and width should be set.]
< Param: Grid/FootprintLength = "0.0"                        [Footprint length used to filter points over the footprint of the robot.]
< Param: Grid/FootprintWidth = "0.0"                         [Footprint width used to filter points over the footprint of the robot. Footprint length should be set.]
< Param: Grid/FromDepth = "true"                             [Create occupancy grid from depth image(s), otherwise it is created from laser scan.]
< Param: Grid/MapFrameProjection = "false"                   [Projection in map frame. On a 3D terrain and a fixed local camera transform (the cloud is created relative to ground), you may want to disable this to do the projection in robot frame instead.]
< Param: Grid/MaxGroundAngle = "45"                          [[Grid/NormalsSegmentation=true] Maximum angle (degrees) between point's normal to ground's normal to label it as ground. Points with higher angle difference are considered as obstacles.]
< Param: Grid/MaxGroundHeight = "0.0"                        [Maximum ground height (0=disabled). Should be set if "Grid/NormalsSegmentation" is true.]
< Param: Grid/MaxObstacleHeight = "0.0"                      [Maximum obstacles height (0=disabled).]
< Param: Grid/MinClusterSize = "10"                          [[Grid/NormalsSegmentation=true] Minimum cluster size to project the points.]
< Param: Grid/MinGroundHeight = "0.0"                        [Minimum ground height (0=disabled).]
< Param: Grid/NoiseFilteringMinNeighbors = "5"               [Noise filtering minimum neighbors.]
< Param: Grid/NoiseFilteringRadius = "0.0"                   [Noise filtering radius (0=disabled). Done after segmentation.]
< Param: Grid/NormalK = "10"                                 [[Grid/NormalsSegmentation=true] K neighbors to compute normals.]
< Param: Grid/NormalsSegmentation = "true"                   [Segment ground from obstacles using point normals, otherwise a fast passthrough is used.]
< Param: Grid/Scan2dMaxFilledRange = "4.0"                   [Unknown space filled maximum range. If 0, the laser scan maximum range is used.]
< Param: Grid/Scan2dUnknownSpaceFilled = "false"             [Unknown space filled. Only used with 2D laser scans.]
< Param: Grid/ScanDecimation = "1"                           [[Grid/FromDepth=false] Decimation of the laser scan before creating cloud.]
< Param: Icp/CorrespondenceRatio = "0.2"                     [Ratio of matching correspondences to accept the transform.]
< Param: Icp/DownsamplingStep = "1"                          [Downsampling step size (1=no sampling). This is done before uniform sampling.]
< Param: Icp/Epsilon = "0"                                   [Set the transformation epsilon (maximum allowable difference between two consecutive transformations) in order for an optimization to be considered as having converged to the final solution.]
< Param: Icp/Iterations = "30"                               [Max iterations.]
< Param: Icp/MaxCorrespondenceDistance = "0.05"              [Max distance for point correspondences.]
< Param: Icp/MaxRotation = "0.78"                            [Maximum ICP rotation correction accepted (rad).]
< Param: Icp/MaxTranslation = "0.2"                          [Maximum ICP translation correction accepted (m).]
< Param: Icp/PointToPlane = "false"                          [Use point to plane ICP.]
< Param: Icp/PointToPlaneNormalNeighbors = "20"              [Number of neighbors to compute normals for point to plane.]
< Param: Icp/VoxelSize = "0.0"                               [Uniform sampling voxel size (0=disabled).]
< Param: Kp/BadSignRatio = "0.5"                             [Bad signature ratio (less than Ratio x AverageWordsPerImage = bad).]
< Param: Kp/DetectorStrategy = "0"                           [0=SURF 1=SIFT 2=ORB 3=FAST/FREAK 4=FAST/BRIEF 5=GFTT/FREAK 6=GFTT/BRIEF 7=BRISK 8=GFTT/ORB.]
< Param: Kp/DictionaryPath = ""                              [Path of the pre-computed dictionary]
< Param: Kp/IncrementalDictionary = "true"                   []
< Param: Kp/IncrementalFlann = "true"                        [When using FLANN based strategy, add/remove points to its index without always rebuilding the index (the index is built only when the dictionary doubles in size).]
< Param: Kp/MaxDepth = "0"                                   [Filter extracted keypoints by depth (0=inf).]
< Param: Kp/MaxFeatures = "400"                              [Maximum features extracted from the images (0 means not bounded, <0 means no extraction).]
< Param: Kp/MinDepth = "0"                                   [Filter extracted keypoints by depth.]
< Param: Kp/NNStrategy = "1"                                 [kNNFlannNaive=0, kNNFlannKdTree=1, kNNFlannLSH=2, kNNBruteForce=3, kNNBruteForceGPU=4]
< Param: Kp/NewWordsComparedTogether = "true"                [When adding new words to dictionary, they are compared also with each other (to detect same words in the same signature).]
< Param: Kp/NndrRatio = "0.8"                                [NNDR ratio (A matching pair is detected, if its distance is closer than X times the distance of the second nearest neighbor.)]
< Param: Kp/Parallelized = "true"                            [If the dictionary update and signature creation were parallelized.]
< Param: Kp/RoiRatios = "0.0 0.0 0.0 0.0"                    [Region of interest ratios [left, right, top, bottom].]
< Param: Kp/SubPixEps = "0.02"                               [See cv::cornerSubPix().]
< Param: Kp/SubPixIterations = "0"                           [See cv::cornerSubPix(). 0 disables sub pixel refining.]
< Param: Kp/SubPixWinSize = "3"                              [See cv::cornerSubPix().]
< Param: Kp/TfIdfLikelihoodUsed = "true"                     [Use of the td-idf strategy to compute the likelihood.]
< Param: Mem/BadSignaturesIgnored = "false"                  [Bad signatures are ignored.]
< Param: Mem/BinDataKept = "true"                            [Keep binary data in db.]
< Param: Mem/GenerateIds = "true"                            [True=Generate location IDs, False=use input image IDs.]
< Param: Mem/ImageKept = "false"                             [Keep raw images in RAM.]
< Param: Mem/ImagePostDecimation = "1"                       [Image decimation (>=1) of saved data in created signatures (after features extraction). Decimation is done from the original image. Negative decimation is done from RGB size instead of depth size (if depth is smaller than RGB, it may be interpolated depending of the decimation value).]
< Param: Mem/ImagePreDecimation = "1"                        [Image decimation (>=1) before features extraction. Negative decimation is done from RGB size instead of depth size (if depth is smaller than RGB, it may be interpolated depending of the decimation value).]
< Param: Mem/IncrementalMemory = "true"                      [SLAM mode, otherwise it is Localization mode.]
< Param: Mem/InitWMWithAllNodes = "false"                    [Initialize the Working Memory with all nodes in Long-Term Memory. When false, it is initialized with nodes of the previous session.]
< Param: Mem/LaserScanDownsampleStepSize = "1"               [If > 1, downsample the laser scans when creating a signature.]
< Param: Mem/LaserScanNormalK = "0"                          [If > 0 and laser scans are 3D without normals, normals will be computed with K search neighbors when creating a signature.]
< Param: Mem/MapLabelsAdded = "true"                         [Create map labels. The first node of a map will be labelled as "map#" where # is the map ID.]
< Param: Mem/NotLinkedNodesKept = "true"                     [Keep not linked nodes in db (rehearsed nodes and deleted nodes).]
< Param: Mem/RawDescriptorsKept = "true"                     [Raw descriptors kept in memory.]
< Param: Mem/RecentWmRatio = "0.2"                           [Ratio of locations after the last loop closure in WM that cannot be transferred.]
< Param: Mem/ReduceGraph = "false"                           [Reduce graph. Merge nodes when loop closures are added (ignoring those with user data set).]
< Param: Mem/RehearsalIdUpdatedToNewOne = "false"            [On merge, update to new id. When false, no copy.]
< Param: Mem/RehearsalSimilarity = "0.6"                     [Rehearsal similarity.]
< Param: Mem/RehearsalWeightIgnoredWhileMoving = "false"     [When the robot is moving, weights are not updated on rehearsal.]
< Param: Mem/STMSize = "10"                                  [Short-term memory size.]
< Param: Mem/SaveDepth16Format = "false"                     [Save depth image into 16 bits format to reduce memory used. Warning: values over ~65 meters are ignored (maximum 65535 millimeters).]
< Param: Mem/TransferSortingByWeightId = "false"             [On transfer, signatures are sorted by weight->ID only (i.e. the oldest of the lowest weighted signatures are transferred first). If false, the signatures are sorted by weight->Age->ID (i.e. the oldest inserted in WM of the lowest weighted signatures are transferred first). Note that retrieval updates the age, not the ID.]
< Param: Mem/UseOdomFeatures = "false"                       [Use odometry features.]
114,144c30,58
< Param: Optimizer/Epsilon = "0.00001"                       [Stop optimizing when the error improvement is less than this value.]
< Param: Optimizer/Iterations = "100"                        [Optimization iterations.]
< Param: Optimizer/Robust = "false"                          [Robust graph optimization using Vertigo (only work for g2o and GTSAM optimization strategies). Not compatible with "RGBD/OptimizeMaxError" if enabled.]
< Param: Optimizer/Strategy = "0"                            [Graph optimization strategy: 0=TORO, 1=g2o and 2=GTSAM.]
< Param: Optimizer/VarianceIgnored = "false"                 [Ignore constraints' variance. If checked, identity information matrix is used for each constraint. Otherwise, an information matrix is generated from the variance saved in the links.]
< Param: RGBD/AngularUpdate = "0.1"                          [Minimum angular displacement to update the map. Rehearsal is done prior to this, so weights are still updated.]
< Param: RGBD/CreateOccupancyGrid = "true"                   [Create local occupancy grid maps. See "Grid" group for parameters.]
< Param: RGBD/Enabled = "true"                               []
< Param: RGBD/GoalReachedRadius = "0.5"                      [Goal reached radius (m).]
< Param: RGBD/GoalsSavedInUserData = "false"                 [When a goal is received and processed with success, it is saved in user data of the location with this format: "GOAL:#".]
< Param: RGBD/LinearUpdate = "0.1"                           [Minimum linear displacement to update the map. Rehearsal is done prior to this, so weights are still updated.]
< Param: RGBD/LocalImmunizationRatio = "0.25"                [Ratio of working memory for which local nodes are immunized from transfer.]
< Param: RGBD/LocalRadius = "10"                             [Local radius (m) for nodes selection in the local map. This parameter is used in some approaches about the local map management.]
< Param: RGBD/LoopClosureReextractFeatures = "false"         [Extract features even if there are some already in the nodes.]
< Param: RGBD/MaxLocalRetrieved = "2"                        [Maximum local locations retrieved (0=disabled) near the current pose in the local map or on the current planned path (those on the planned path have priority).]
< Param: RGBD/NeighborLinkRefining = "false"                 [When a new node is added to the graph, the transformation of its neighbor link to the previous node is refined using registration approach selected (Reg/Strategy).]
< Param: RGBD/NewMapOdomChangeDistance = "0"                 [A new map is created if a change of odometry translation greater than X m is detected (0 m = disabled).]
< Param: RGBD/OptimizeFromGraphEnd = "false"                 [Optimize graph from the newest node. If false, the graph is optimized from the oldest node of the current graph (this adds an overhead computation to detect to oldest mode of the current graph, but it can be useful to preserve the map referential from the oldest node). Warning when set to false: when some nodes are transferred, the first referential of the local map may change, resulting in momentary changes in robot/map position (which are annoying in teleoperation).]
< Param: RGBD/OptimizeMaxError = "1"                         [Reject loop closures if optimization error is greater than this value (0=disabled). This will help to detect when a wrong loop closure is added to the graph. Not compatible with "Optimizer/Robust" if enabled.]
< Param: RGBD/PlanAngularVelocity = "0"                      [Angular velocity (rad/sec) used to compute path weights.]
< Param: RGBD/PlanLinearVelocity = "0"                       [Linear velocity (m/sec) used to compute path weights.]
< Param: RGBD/PlanStuckIterations = "0"                      [Mark the current goal node on the path as unreachable if it is not updated after X iterations (0=disabled). If all upcoming nodes on the path are unreachabled, the plan fails.]
< Param: RGBD/ProximityAngle = "45"                          [Maximum angle (degrees) for visual proximity detection.]
< Param: RGBD/ProximityBySpace = "true"                      [Detection over locations (in Working Memory or STM) near in space.]
< Param: RGBD/ProximityByTime = "false"                      [Detection over all locations in STM.]
< Param: RGBD/ProximityMaxGraphDepth = "50"                  [Maximum depth from the current/last loop closure location and the local loop closure hypotheses. Set 0 to ignore.]
< Param: RGBD/ProximityMaxPaths = "3"                        [Maximum paths compared (from the most recent) for proximity detection by space. 0 means no limit.]
< Param: RGBD/ProximityPathFilteringRadius = "0.5"           [Path filtering radius to reduce the number of nodes to compare in a path. A path should also be inside that radius to be considered for proximity detection.]
< Param: RGBD/ProximityPathMaxNeighbors = "10"               [Maximum neighbor nodes compared on each path.]
< Param: RGBD/ProximityPathRawPosesUsed = "true"             [When comparing to a local path, merge the scan using the odometry poses (with neighbor link optimizations) instead of the ones in the optimized local graph.]
< Param: RGBD/ScanMatchingIdsSavedInLinks = "true"           [Save scan matching IDs in link's user data.]
---
> Param: Odom/AlignWithGround = "false"                      [Align odometry with the ground on initialization.]
> Param: Odom/FillInfoData = "true"                          [Fill info with data (inliers/outliers features).]
> Param: Odom/FilteringStrategy = "0"                        [0=No filtering 1=Kalman filtering 2=Particle filtering]
> Param: Odom/GuessMotion = "false"                          [Guess next transformation from the last motion computed.]
> Param: Odom/Holonomic = "true"                             [If the robot is holonomic (strafing commands can be issued). If not, y value will be estimated from x and yaw values (y=x*tan(yaw)).]
> Param: Odom/ImageBufferSize = "1"                          [Data buffer size (0 min inf).]
> Param: Odom/ImageDecimation = "1"                          [Decimation of the images before registration. Negative decimation is done from RGB size instead of depth size (if depth is smaller than RGB, it may be interpolated depending of the decimation value).]
> Param: Odom/KalmanMeasurementNoise = "0.01"                [Process measurement covariance value.]
> Param: Odom/KalmanProcessNoise = "0.001"                   [Process noise covariance value.]
> Param: Odom/KeyFrameThr = "0.3"                            [[Visual] Create a new keyframe when the number of inliers drops under this ratio of features in last frame. Setting the value to 0 means that a keyframe is created for each processed frame.]
> Param: Odom/ParticleLambdaR = "100"                        [Lambda of rotational components (roll,pitch,yaw).]
> Param: Odom/ParticleLambdaT = "100"                        [Lambda of translation components (x,y,z).]
> Param: Odom/ParticleNoiseR = "0.002"                       [Noise (rad) of rotational components (roll,pitch,yaw).]
> Param: Odom/ParticleNoiseT = "0.002"                       [Noise (m) of translation components (x,y,z).]
> Param: Odom/ParticleSize = "400"                           [Number of particles of the filter.]
> Param: Odom/ResetCountdown = "0"                           [Automatically reset odometry after X consecutive images on which odometry cannot be computed (value=0 disables auto-reset).]
> Param: Odom/ScanKeyFrameThr = "0.7"                        [[Geometry] Create a new keyframe when the number of ICP inliers drops under this ratio of points in last frame's scan. Setting the value to 0 means that a keyframe is created for each processed frame.]
> Param: Odom/Strategy = "0"                                 [0=Frame-to-Map (F2M) 1=Frame-to-Frame (F2F)]
> Param: Odom/VisKeyFrameThr = "100"                         [[Visual] Create a new keyframe when the number of inliers drops under this threshold. Setting the value to 0 means that a keyframe is created for each processed frame.]
> Param: OdomF2M/BundleAdjustment = "0"                      [Local bundle adjustment: 0=disabled, 1=g2o, 2=cvsba.]
> Param: OdomF2M/BundleAdjustmentMaxFrames = "0"             [Maximum frames used for bundle adjustment (0=inf or all current frames in the local map).]
> Param: OdomF2M/MaxNewFeatures = "0"                        [[Visual] Maximum features (sorted by keypoint response) added to local map from a new key-frame. 0 means no limit.]
> Param: OdomF2M/MaxSize = "2000"                            [[Visual] Local map size: If > 0 (example 5000), the odometry will maintain a local map of X maximum words.]
> Param: OdomF2M/ScanMaxSize = "2000"                        [[Geometry] Maximum local scan map size.]
> Param: OdomF2M/ScanSubtractRadius = "0.05"                 [[Geometry] Radius used to filter points of a new added scan to local map. This could match the voxel size of the scans.]
> Param: OdomMono/InitMinFlow = "100"                        [Minimum optical flow required for the initialization step.]
> Param: OdomMono/InitMinTranslation = "0.1"                 [Minimum translation required for the initialization step.]
> Param: OdomMono/MaxVariance = "0.01"                       [Maximum variance to add new points to local map.]
> Param: OdomMono/MinTranslation = "0.02"                    [Minimum translation to add new points to local map. On initialization, translation x 5 is used as the minimum.]
148,165d61
< Param: Rtabmap/CreateIntermediateNodes = "false"           [Create intermediate nodes between loop closure detection. Only used when Rtabmap/DetectionRate>0.]
< Param: Rtabmap/DetectionRate = "1"                         [Detection rate. RTAB-Map will filter input images to satisfy this rate.]
< Param: Rtabmap/ImageBufferSize = "1"                       [Data buffer size (0 min inf).]
< Param: Rtabmap/LoopRatio = "0"                             [The loop closure hypothesis must be over LoopRatio x lastHypothesisValue.]
< Param: Rtabmap/LoopThr = "0.11"                            [Loop closing threshold.]
< Param: Rtabmap/MaxRetrieved = "2"                          [Maximum locations retrieved at the same time from LTM.]
< Param: Rtabmap/MemoryThr = "0"                             [Maximum signatures in the Working Memory (ms) (0 means infinity).]
< Param: Rtabmap/PublishLastSignature = "true"               [Publishing last signature.]
< Param: Rtabmap/PublishLikelihood = "true"                  [Publishing likelihood.]
< Param: Rtabmap/PublishPdf = "true"                         [Publishing pdf.]
< Param: Rtabmap/PublishStats = "true"                       [Publishing statistics.]
< Param: Rtabmap/StartNewMapOnLoopClosure = "false"          [Start a new map only if there is a global loop closure with a previous map.]
< Param: Rtabmap/StatisticLogged = "false"                   [Logging enabled.]
< Param: Rtabmap/StatisticLoggedHeaders = "true"             [Add column header description to log files.]
< Param: Rtabmap/StatisticLogsBufferedInRAM = "true"         [Statistic logs buffered in RAM instead of written to hard drive after each iteration.]
< Param: Rtabmap/TimeThr = "0"                               [Maximum time allowed for the detector (ms) (0 means infinity).]
< Param: Rtabmap/VhStrategy = "0"                            [None 0, Similarity 1, Epipolar 2.]
< Param: Rtabmap/WorkingDirectory = "/root/.ros"             [Working directory.]
178,198d73
< Param: Stereo/Eps = "0.01"                                 [[Stereo/OpticalFlow=true] Epsilon stop criterion.]
< Param: Stereo/Iterations = "30"                            [Maximum iterations.]
< Param: Stereo/MaxDisparity = "128"                         [Maximum disparity.]
< Param: Stereo/MaxLevel = "3"                               [Maximum pyramid level.]
< Param: Stereo/MinDisparity = "1"                           [Minimum disparity.]
< Param: Stereo/OpticalFlow = "true"                         [Use optical flow to find stereo correspondences, otherwise a simple block matching approach is used.]
< Param: Stereo/SSD = "true"                                 [[Stereo/OpticalFlow=false] Use Sum of Squared Differences (SSD) window, otherwise Sum of Absolute Differences (SAD) window is used.]
< Param: Stereo/WinHeight = "3"                              [Window height.]
< Param: Stereo/WinWidth = "15"                              [Window width.]
< Param: StereoBM/BlockSize = "15"                           [See cv::StereoBM]
< Param: StereoBM/MinDisparity = "0"                         [See cv::StereoBM]
< Param: StereoBM/NumDisparities = "128"                     [See cv::StereoBM]
< Param: StereoBM/PreFilterCap = "31"                        [See cv::StereoBM]
< Param: StereoBM/PreFilterSize = "9"                        [See cv::StereoBM]
< Param: StereoBM/SpeckleRange = "4"                         [See cv::StereoBM]
< Param: StereoBM/SpeckleWindowSize = "100"                  [See cv::StereoBM]
< Param: StereoBM/TextureThreshold = "10"                    [See cv::StereoBM]
< Param: StereoBM/UniquenessRatio = "15"                     [See cv::StereoBM]
< Param: VhEp/MatchCountMin = "8"                            [Minimum of matching visual words pairs to accept the loop hypothesis.]
< Param: VhEp/RansacParam1 = "3"                             [Fundamental matrix (see cvFindFundamentalMat()): Max distance (in pixels) from the epipolar line for a point to be inlier.]
< Param: VhEp/RansacParam2 = "0.99"                          [Fundamental matrix (see cvFindFundamentalMat()): Performance of the RANSAC.]
226,231c101
< Param: g2o/Baseline = "0.075"                              [When doing bundle adjustment with RGB-D data, we can set a fake baseline (m) to do stereo bundle adjustment (if 0, mono bundle adjustment is done). For stereo data, the baseline in the calibration is used directly.]
< Param: g2o/Optimizer = "0"                                 [0=Levenberg 1=GaussNewton]
< Param: g2o/PixelVariance = "1.0"                           [Pixel variance used for bundle adjustment.]
< Param: g2o/RobustKernelDelta = "8"                         [Robust kernel delta used for bundle adjustment (0 means don't use robust kernel). Observations with chi2 over this threshold will be ignored in the second optimization pass.]
< Param: g2o/Solver = "0"                                    [0=csparse 1=pcg 2=cholmod 3=Eigen]
< [33m[ WARN] [1511100480.838828642]: Node will now exit after showing default RTAB-Map parameters because argument "--params" is detected![0m
---
> [33m[ WARN] [1511100489.777271411]: Node will now exit after showing default odometry parameters because argument "--params" is detected![0m
